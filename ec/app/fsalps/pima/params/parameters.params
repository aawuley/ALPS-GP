# Anthony Awuley
# COSC5P71 - Genetic Programming
# Testing ALPS - Pima Indians Diabetes - Parameter file

parent.0                = ../../../../gp/koza/koza.params
quit-on-run-complete    = false

#jobs specifies the number of runs you would wish to perform
state                   = ec.alps.GenEvolutionState
finish                  = ec.simple.SimpleFinisher
exch                    = ec.simple.SimpleExchanger
breed                   = ec.alps.ALPSBreeder
eval                    = ec.alps.ALPSEvaluator
stat                    = ec.alps.statistics.ALPSStatistics
init                    = ec.alps.fsalps.FSALPSGPInitializer
pop                     = ec.Population
jobs                    = 20
pop.subpops             = 1
pop.subpop.0.size       = 50
select.tournament.size  = 3
breed.elite.0           = 0
breedthreads            = 1
evalthreads             = 1
seed.0                  = 1
generations             = 1000
cross-validation-size   = 20


#Begin ALPS configuration ==============================================================
alps.age-gap                           = 5
alps.number-of-layers                  = 10
alps.number-of-evaluations             = 2000
alps.selection-pressure                = 0.8
alps.tournament-size                   = 3
alps.aging-scheme                      = ec.alps.layers.agingscheme.Polynomial
alps.layer-replacement                 = ec.alps.layers.replacement.ReverseTournamentWorst

# when using selection pressure, individual aging isnt uniform especially when parents are selected from lower
# layer. When some individuals are aged faster than others, a population will contain less than expected required number
# ECJ by default breeds a maximum of the number of populations contained in a population.
alps.always-breed-maximum-population   = true

#when true, only individuals selected from breeding from current layer have their age increased
#else both both individuals coming from current and lower layer used as parents will have their age increased
alps.age-only-current-layer            = true

# when moving old individuals from bottom layer to next higher layer, use this flag to determine
# replacement strategy in higher layer. if false lower layer individual only replace higher layer individual
# if its fitness is better that of the higher layer individual. if true, selected tournament individual from higher
# layer is always replaced
alps.layer-replacement.replace-weakest = false

#END======================================================================================



#BEGIN FSALPS ============================================================================
#use only default node probability
alps.use-only-default-node-pr         = false

# used to determine if frequency count is used during mutation
# DEPRECATED: a simpler solutioin involves setting gp.koza.mutate.build.0 = ec.gp.koza.GrowBuilder for situations
# where mutation is to be excluded from FSALPS
alps.fsalps-in-mutation               = true

# used to determine if frequency in last layer is used to generate probality selection on a generational basis
alps.fsalps-last-layer-gen-freq-count = false

# when enabled, nodes are counted in all layers and converted
# to probability values used during mutation and tree initialization in bottom layer
alps.fsalps-use-all-layers            = false

# Determine which frequency selection criteria is used for generating probability
alps.fsalps.probability-selection     = ec.alps.fsalps.probability.NormalFrequency
        

#ec.gp.koza.koza.params

# Point Mutation will use Tournament Selection, try only 1
# time, have a max depth of 17, and use KozaNodeSelector
# and GROW for building.  Also, Point Mutation uses a GrowBuilder
# by default, with a default of min-depth=max-depth=5
# as shown a ways below
gp.koza.mutate.source.0      = ec.select.TournamentSelection
gp.koza.mutate.ns.0          = ec.gp.koza.KozaNodeSelector
gp.koza.mutate.build.0       = ec.alps.gp.koza.GrowBuilder
gp.koza.mutate.maxdepth      = 17
# This is the default for Koza and lil-gp, though it's
# a little wimpy; on the other hand, a higher number can
# make things really slow
gp.koza.mutate.tries         = 1


# The tree uses an ec.gp.koza.HalfBuilder to create
# itself initially.
# HalfBuilder will pick GROW half the time and FULL
# the other half, with a ramp from 2 to 6 inclusive.
# By ramp we mean that it first picks a random number between
# 2 and 6 inclusive.  This then becomes the *maximum* tree size
# (for the FULL approach, it's the tree size of the tree, for
# GROW, the tree can get no bigger than this)

#This is to ensure that the modified KozaBuilder and GrowBuilder in alps.gp.koza are used during tree initialization
gp.tc.0.init                 = ec.alps.gp.koza.HalfBuilder

# We set the default for HalfBuilder to be a ramp of 2--6,
# with a grow probability of 0.5
gp.koza.half.min-depth       = 2
gp.koza.half.max-depth       = 6
gp.koza.half.growp           = 0.5

#END FSALPS =========================================================================


#Begin GP parameters ================================================================
pop.subpop.0.species.pipe                        = ec.alps.gp.ALPSMultiBreedingPipeline
pop.subpop.0.species.pipe.num-sources            = 2
pop.subpop.0.species.pipe.source.0               = ec.alps.gp.breed.Crossover
pop.subpop.0.species.pipe.source.0.source.0      = ec.select.TournamentSelection
pop.subpop.0.species.pipe.source.0.source.1      = same
pop.subpop.0.species.pipe.source.0.ns.0          = ec.gp.koza.KozaNodeSelector
pop.subpop.0.species.pipe.source.0.ns.1          = same
pop.subpop.0.species.pipe.source.0.maxdepth      = 17
pop.subpop.0.species.pipe.source.0.tries         = 1
#pop.subpop.0.species.pipe.source.0.source.0.size = 7
#pop.subpop.0.species.pipe.source.0.source.1.size = 7
pop.subpop.0.species.pipe.source.0.prob          = 0.90

pop.subpop.0.species.pipe.source.1               = ec.alps.gp.breed.Mutation
pop.subpop.0.species.pipe.source.0.source.0      = ec.select.TournamentSelection
pop.subpop.0.species.pipe.source.0.source.0.size = 7
#pop.subpop.0.species.pipe.source.1.prob          = 0.10

#Node Selectors
gp.koza.ns.terminals                             = 0.1
gp.koza.ns.nonterminals                          = 0.9
gp.koza.ns.root                                  = 0.0
#END================================================================================= 


#Begin NODES ========================================================================
gp.nc.size        = 3

gp.nc.0           = ec.gp.GPNodeConstraints
gp.nc.0.name      = nc0
gp.nc.0.returns   = nil
gp.nc.0.size      = 0

gp.nc.1           = ec.gp.GPNodeConstraints
gp.nc.1.name      = nc1
gp.nc.1.returns   = nil
gp.nc.1.size      = 1
gp.nc.1.child.0   = nil

gp.nc.2           = ec.gp.GPNodeConstraints
gp.nc.2.name      = nc2
gp.nc.2.returns   = nil
gp.nc.2.size      = 2
gp.nc.2.child.0   = nil
gp.nc.2.child.1   = nil


# Assign all function/terminal set to the GP primitive set.
# NB: Added function set: Div, Max & Min
gp.fs.size         = 1
gp.fs.0            = ec.alps.fsalps.FSALPSGPFunctionSet
gp.fs.0.name       = f0

gp.fs.0.size       = 17
gp.fs.0.func.0     = ec.app.fsalps.pima.ts.NumbTimesPreg
gp.fs.0.func.0.nc  = nc0
gp.fs.0.func.0.pr  = 0
gp.fs.0.func.1     = ec.app.fsalps.pima.ts.PlasmaGlucoseConc
gp.fs.0.func.1.nc  = nc0
gp.fs.0.func.1.pr  = 0
gp.fs.0.func.2     = ec.app.fsalps.pima.ts.DiastolicBP
gp.fs.0.func.2.nc  = nc0
gp.fs.0.func.2.pr  = 0
gp.fs.0.func.3     = ec.app.fsalps.pima.ts.TricepsSkinFoldThickness
gp.fs.0.func.3.nc  = nc0
gp.fs.0.func.3.pr  = 0
gp.fs.0.func.4     = ec.app.fsalps.pima.ts.TwoHourSerumInsulin
gp.fs.0.func.4.nc  = nc0
gp.fs.0.func.4.pr  = 0
gp.fs.0.func.5     = ec.app.fsalps.pima.ts.BMI
gp.fs.0.func.5.nc  = nc0
gp.fs.0.func.5.pr  = 0
gp.fs.0.func.6     = ec.app.fsalps.pima.ts.DiabetesPedigreeFunction
gp.fs.0.func.6.nc  = nc0
gp.fs.0.func.6.pr  = 0
gp.fs.0.func.7     = ec.app.fsalps.pima.ts.Age
gp.fs.0.func.7.nc  = nc0
gp.fs.0.func.7.pr  = 0
gp.fs.0.func.8     = ec.app.fsalps.pima.ts.RegERC
gp.fs.0.func.8.nc  = nc0
gp.fs.0.func.8.pr  = 0
gp.fs.0.func.9     = ec.app.fsalps.pima.fs.Add
gp.fs.0.func.9.nc  = nc2
gp.fs.0.func.10    = ec.app.fsalps.pima.fs.Sub
gp.fs.0.func.10.nc = nc2
gp.fs.0.func.11    = ec.app.fsalps.pima.fs.Mul
gp.fs.0.func.11.nc = nc2
gp.fs.0.func.12    = ec.app.fsalps.pima.fs.Div
gp.fs.0.func.12.nc = nc2
gp.fs.0.func.13    = ec.app.fsalps.pima.fs.Max
gp.fs.0.func.13.nc = nc2
gp.fs.0.func.14    = ec.app.fsalps.pima.fs.Min
gp.fs.0.func.14.nc = nc2
gp.fs.0.func.15    = ec.app.fsalps.pima.fs.Ln
gp.fs.0.func.15.nc = nc1
gp.fs.0.func.16    = ec.app.fsalps.pima.fs.Log10
gp.fs.0.func.16.nc = nc1
#END=================================================================================

eval.problem = ec.app.fsalps.pima.Pima
eval.problem.data = ec.app.fsalps.pima.DoubleData
# shuffle data when a cycle of kfold cross validation is completed
# when not shuffled, this will be like testing the same data sample
# n times. where n = jobs/cross-validation-size
eval.problem.kfold-cycle-data-shuffle = true

eval.problem.pima-indians-diabetes-data-raw        = /Users/anthony/git/ecj22/ec/app/fsalps/pima/data/pima-indians-diabetes-data.txt
eval.problem.pima-indians-diabetes-data-clean      = /Users/anthony/git/ecj22/ec/app/fsalps/pima/data/pima-indians-diabetes-data-new.txt
eval.problem.pima-indians-diabetes-data-train-data = /Users/anthony/git/ecj22/ec/app/fsalps/pima/data/pima-indians-diabetes-train-data.txt
eval.problem.pima-indians-diabetes-data-test-data  = /Users/anthony/git/ecj22/ec/app/fsalps/pima/data/pima-indians-diabetes-test-data.txt

eval.problem.total-number-of-points        = 168

#Specification of output statistics files

stat.num-children           = 3
stat.child.0                = ec.alps.statistics.ShortStatistics
stat.child.0.file           = ../output/cmtrx.stats
stat.child.1                = ec.alps.statistics.ALPSStatistics
stat.child.1.silent.print   = true
stat.child.1.file           = ../output/ss.stats
stat.child.2                = ec.alps.statistics.NodeStatistics
stat.child.2.silent.print   = true
stat.child.2.file           = ../output/node.stats